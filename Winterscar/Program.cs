//todo next: swords break when they colide

Map map = new Map(11, 11);
while (true)
{
    map.PrintFull();
    map.Tick(GetPlayerInput(map.P1NextActions), 10);
}



/*
 * Player input conversion:
 *
 *  w (forward) = 0
 *  d (turn left) = 1
 *  s (backward) = 2
 *  a (turn right) = 3
 *  i (swing forward) = 4
 *  l (swing right) = 5
 *  k (arrow) = 6
 *  j (swing left) = 7
 *  Space (dodge) = 8
 */
int GetPlayerInput(List<int> nextActions)
{
    if (nextActions.Count > 0)
    {
        Console.WriteLine(nextActions.Count);
        int nextAction = nextActions[0];
        nextActions.RemoveAt(0);
        return nextAction;
    }
    char input = Console.ReadKey().KeyChar;
    switch (input)
    {
        case 'w':
            return 0;
        case 'd':
            return 1;
        case 's':
            return 2;
        case 'a':
            return 3;
        case 'i':
            return 4;
        case 'l':
            return 5;
        case 'k':
            return 6;
        case 'j':
            return 7;
        case ' ':
            return 8;

    }

    return 8;
}

class Coordinate
{
    public int X { get;}
    public int Y { get;}
    public Coordinate(int x, int y)
    {
        X = x;
        Y = y;
    }

    public static Coordinate operator +(Coordinate a, Coordinate b)
    {
        return new Coordinate(a.X + b.X, a.Y + b.Y);
    }
    public static Coordinate operator -(Coordinate a, Coordinate b)
    {
        return new Coordinate(a.X - b.X, a.Y - b.Y);
    }

    public override string ToString()
    {
        return $"({X}, {Y})";
    }
    
    public bool Equals(Coordinate other)
    {
        return X == other.X && Y == other.Y;
    }

    public double Magnitude()
    {
        return Math.Sqrt(X * X + Y * Y);
    }
    
    
}

class Polar
{
    public double Angle { get; }
    public double Distance { get; }

    public Polar(double distance, double angle)
    {
        Angle = angle;
        Distance = distance;
    }

    public Polar(Coordinate observer, Coordinate location)
    {
        Coordinate difference = location - observer;

        Distance = difference.Magnitude();
        
        Angle = Math.Atan2(difference.Y, difference.X);
        

    }
    
}


class Map
{
    private int[,] BaseLayer; // 0 = ground, 1 = wall
    private int[,] Players; // 1 = p1, -1 = p2
    private int[,] Swords; // 1 = p1, -1 = p2
    private int[,] DamageZones; // 0 = empty, 1 = damage
    private int Width;
    private int Height;
    private bool[] Invunerable;
    public int winner;
    
    //used for action lock and similar, empty is normal
    public List<int> P1NextActions = new List<int>();
    public List<int> P2NextActions = new List<int>();
    
    private List<int[,]> sideSwing = new List<int[,]>();
    private List<int[,]> forwardSwing = new List<int[,]>();
    private List<int[,]> lunge = new List<int[,]>();                
    
    public Map(int width, int height)
    {
        winner = 0;
        Width = width;
        Height = height;
        if (height < 6 || width < 3)
        {
            throw new Exception("map not large enough");
        }

        if (width % 2 == 0)
        {
            try
            {
                throw new Exception("Even map width; start positions broken");
            }
            catch{}
          
            
        }
        
        
        // these were autogenerated with an array turner, rotations of the original to save time in runtime
        forwardSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 1}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 0}});
        forwardSwing.Add(new int[,] {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 1, 0, 0}});
        forwardSwing.Add(new int[,] {{0, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {1, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, 0, 0, 0, 0}});
        forwardSwing.Add(new int[,]{
            {0,0,1,0,0},
            {0,1,0,1,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        
        //WARNING: Needs to start from the left swing and stay vertically symmetrical 
        
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 1, 1, 1, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 1, 1, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{
            {0,0,0,0,0},
            {0,1,0,0,0},
            {0,1,0,0,0},
            {0,1,0,0,0},
            {0,0,0,0,0} });
        
        
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,1,1},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,1,0,0},
            {0,0,1,0,0} });
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {1,1,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        lunge.Add(new int[,]{
            {0,0,1,0,0},
            {0,0,1,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        
        
        
        BaseLayer = new int[width, height];
        Players = new int[width, height];
        DamageZones = new int[width, height];
        Invunerable = new bool[] { false, false };
        Swords = new int[width, height];
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (y > 0 && y < height - 1 && x > 0 && x < width - 1)
                    BaseLayer[x, y] = 0;
                else
                    BaseLayer[x, y] = 1;
            }
        }

        Players[width/2, 1] = 1;
        Players[width/2, height-2] = -1;
        Swords[width/2, 2] = 1;
        Swords[width/2, height-3] = -1;

    }

    
    public void Tick(int player1Input, int player2Input)
    {
        DamageZones = new int[Width, Height];
        Coordinate p1ProposedPosition = new Coordinate(0, 0);
        Coordinate p2ProposedPosition = new Coordinate(0, 0);
        Coordinate p1ProposedSword = new Coordinate(0, 0);
        Coordinate p2ProposedSword = new Coordinate(0, 0);
        for (int player = 1; player >= -1; player-=2)
        {
            Coordinate proposedPosition = GetPlayerCoord(player);
            Coordinate proposedSwordPosition = GetSwordCoord(player);
            Coordinate swordPosition = GetSwordCoord(player);
            Coordinate swordDirection = GetSwordVector(player);
            switch ( player == 1? player1Input : player2Input)
            {
                    
                case 0: //forwards
                    proposedPosition = GetSwordCoord(player);
                    proposedSwordPosition = proposedPosition + swordDirection;
                    break;
                case 1: //Turn Right
                    proposedSwordPosition = new Coordinate(swordDirection.Y + proposedPosition.X,
                        proposedPosition.Y + -swordDirection.X);
                    break;
                case 2: //backwards
                    proposedPosition = proposedPosition - swordDirection;
                    proposedSwordPosition = proposedPosition + swordDirection;
                    break;
                case 3: //Turn Left
                    proposedSwordPosition = new Coordinate(-swordDirection.Y + proposedPosition.X,
                        proposedPosition.Y + swordDirection.X);
                    break;
                case 4: //Swing Forward
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, forwardSwing[GetSwordDirection(player)]);
                    break;
                case 5: //Swing Right
                    int direction = GetSwordDirection(player);
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, sideSwing[direction + direction >= 2? -2:2 ]);
                    break;
                case 6: //Lunge
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, lunge[GetSwordDirection(player)]);
                    if (player == 1)
                    {
                        P1NextActions.Add(9);
                    }
                    else
                    {
                        P2NextActions.Add(9);
                    }
                    break;
                case 7: //Swing Left
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, sideSwing[GetSwordDirection(player)]);
                    break;
                case 8: //Dodge
                    if (player == 1)
                    {
                        P1NextActions.Add(10);
                        Invunerable[0] = true;
                    }
                    else
                    {
                        P2NextActions.Add(10);
                        Invunerable[1] = true;
                    }
                    break;
                case 9: //Lunge pt 2 (Hidden) 
                    proposedPosition = new Coordinate(swordPosition.X + swordDirection.X, swordPosition.Y + swordDirection.Y);
                    proposedSwordPosition = new Coordinate(swordPosition.X + swordDirection.X * 2,
                        swordPosition.Y + swordDirection.Y * 2);
                    break;
                case 10: // Wait (Hidden)
                    break;



                

            }
            if (player == 1)
            {
                p1ProposedPosition = proposedPosition;
                p1ProposedSword = proposedSwordPosition;
            }
            else
            {
                p2ProposedPosition = proposedPosition;
                p2ProposedSword = proposedSwordPosition;
            }
            
            
            
            
            
        }
        
        //If a player's proposed position is in a damage zone, they lose. If both players are in damage zones, they cancel out.
        //If a player's proposed position is in a wall or other player's proposed position, they don't move
        if (DamageZones[p1ProposedPosition.X, p1ProposedPosition.Y] >
            DamageZones[p2ProposedPosition.X, p2ProposedPosition.Y])
        {
            winner = 2;
        }
        else if (DamageZones[p1ProposedPosition.X, p1ProposedPosition.Y] <
                 DamageZones[p2ProposedPosition.X, p2ProposedPosition.Y])
        {
            winner = 1;
        }
        else if (!p1ProposedPosition.Equals(p2ProposedPosition))
        {
            if (BaseLayer[p1ProposedPosition.X, p1ProposedPosition.Y] == 0 && BaseLayer[p1ProposedSword.X, p1ProposedSword.Y] == 0)
            {
                Coordinate p1 = GetPlayerCoord(1);
                Coordinate swordPosition = GetSwordCoord(1);
                Players[p1.X, p1.Y] = 0;
                Players[p1ProposedPosition.X, p1ProposedPosition.Y] = 1;
                Swords[swordPosition.X, swordPosition.Y] = 0;
                Swords[p1ProposedSword.X, p1ProposedSword.Y] = 1;
                
            }

            if (BaseLayer[p2ProposedPosition.X, p2ProposedPosition.Y] == 0&& BaseLayer[p2ProposedSword.X, p2ProposedSword.Y] == 0)
            {
                Coordinate p2 = GetPlayerCoord(-1);
                Coordinate swordPosition = GetSwordCoord(-1);
                Players[p2.X, p2.Y] = 0;
                Players[p2ProposedPosition.X, p2ProposedPosition.Y] = -1;
                Swords[swordPosition.X, swordPosition.Y] = 0;
                Swords[p2ProposedSword.X, p2ProposedSword.Y] = -1;
                
            }
        }
        
        
    }

    public void PrintFull()
    {
        Console.WriteLine();
        for (int y = Height - 1; y >= 0 ; y--)
        {
            for (int x = 0; x < Width ; x++)
            {
                Console.BackgroundColor = ConsoleColor.Black;
                Console.ForegroundColor = ConsoleColor.Black;
                if (DamageZones[x, y] == 1)
                {
                    Console.BackgroundColor = ConsoleColor.Red;
                }
                else if (BaseLayer[x, y] == 0)
                {
                    Console.BackgroundColor = ConsoleColor.DarkYellow;
                }
                if (Players[x, y] != 0)
                {
                    if (Players[x, y] == 1 && Invunerable[0])
                        Console.BackgroundColor = ConsoleColor.Blue;
                    Console.Write(Players[x,y] == 1? "A":"B");
                }
                else if (Swords[x, y] != 0)
                {
                    Console.Write("S");
                }
                else
                {
                    Console.Write($" ");
                }
                
            }
            Console.WriteLine();
        }
        Console.BackgroundColor = ConsoleColor.Black;
        Console.ForegroundColor = ConsoleColor.Gray;
    }

    private Coordinate GetPlayerCoord(int player)
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (Players[x, y] == player)
                    return new Coordinate(x, y);
            }
        }

        throw new Exception("Player not found");
    }
    private Coordinate GetSwordCoord(int player)
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (Swords[x, y] == player)
                    return new Coordinate(x, y);
            }
        }

        throw new Exception("Sword not found");
    }

    private Coordinate GetSwordVector(int player) // acts like a vector from the player, add this to player's pos to get sword pos
    {
        return GetSwordCoord(player) - GetPlayerCoord(player);
    }
    private int GetSwordDirection(int player) // 0 = north, 1, east, 2= south, 3 = west
    {
        Coordinate swordVector = GetSwordVector(player);
        if (swordVector.Equals(new Coordinate(0, 1)))
            return 0;
        if (swordVector.Equals(new Coordinate(1, 0)))
            return 1;
        if (swordVector.Equals(new Coordinate(0, -1)))
            return 2;
        if (swordVector.Equals(new Coordinate(-1, 0)))
            return 3;
        else
        {
            throw new Exception("sword direction broken");
        }
    

    }
    private int[,] GenerateDamageZone(Coordinate centerPos, int[,] damageZones, int[,] swingData)
    {
        int rows = damageZones.GetLength(0);
        int cols = damageZones.GetLength(1);
        int[,] final = new int[rows, cols];
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                final[i, j] = damageZones[i, j];
            }
        }
        
        if (swingData.GetLength(0) % 2 == 0 || swingData.GetLength(1) % 2 == 0)
        {
            throw new Exception("even-sided swing data");
        }



        for (int x = 0; x < swingData.GetLength(0); x++)
        {
            for (int y = 0; y < swingData.GetLength(1); y++)
            {
                Coordinate realArrayPos = new Coordinate(centerPos.X + (-swingData.GetLength(0)) / 2 + x, centerPos.Y + (-swingData.GetLength(1)) / 2 + y);
                if (realArrayPos.X >= 0 && realArrayPos.X < Width && realArrayPos.Y >= 0 && realArrayPos.Y < Height)
                {

                    if (swingData[x, y] == 1)
                    {
                        final[realArrayPos.X, realArrayPos.Y] = 1;
                    }
                      
                }
                

            }
        }

        return final;
    }
    
}

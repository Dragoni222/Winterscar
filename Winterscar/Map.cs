namespace Winterscar;

public class Map
{
    private int[,] BaseLayer; // 0 = ground, 1 = wall
    private int[,] Players; // 1 = p1, -1 = p2
    private int[,] Swords; // 1 = p1, -1 = p2
    private int[,] DamageZones; // 0 = empty, 1 = damage
    private int Width;
    private int Height;
    private bool[] Invunerable;
    public int MaxViewSquares;
    public int MaxViewDistance;
    //used for action lock and similar, empty is normal
    public List<int> P1NextActions = new List<int>();
    public List<int> P2NextActions = new List<int>();
    private List<int[,]> sideSwing = new List<int[,]>();
    private List<int[,]> forwardSwing = new List<int[,]>();
    private List<int[,]> lunge = new List<int[,]>();                
    
    public Map(int width, int height, int maxViewDistance)
    {
        Width = width;
        Height = height;
        MaxViewSquares = (int)((float)maxViewDistance/2) * (2 + (maxViewDistance - 1) * 2);
        MaxViewDistance = maxViewDistance;
        Console.ReadLine();
        if (height < 6 || width < 3)
        {
            throw new Exception("map not large enough");
        }

        if (width % 2 == 0)
        {
            try
            {
                throw new Exception("Even map width; start positions broken");
            }
            catch{}
          
            
        }
        
        
        // these were autogenerated with an array turner, rotations of the original to save time in runtime
        forwardSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 1}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 0}});
        forwardSwing.Add(new int[,] {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 1, 0, 0}});
        forwardSwing.Add(new int[,] {{0, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {1, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, 0, 0, 0, 0}});
        forwardSwing.Add(new int[,]{
            {0,0,1,0,0},
            {0,1,0,1,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        
        //WARNING: Needs to start from the left swing and stay vertically symmetrical 
        
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 1, 1, 1, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 1, 1, 0}, {0, 0, 0, 0, 0}});
        sideSwing.Add(new int[,]{
            {0,0,0,0,0},
            {0,1,0,0,0},
            {0,1,0,0,0},
            {0,1,0,0,0},
            {0,0,0,0,0} });
        
        
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,1,1},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,1,0,0},
            {0,0,1,0,0} });
        lunge.Add(new int[,]{
            {0,0,0,0,0},
            {0,0,0,0,0},
            {1,1,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        lunge.Add(new int[,]{
            {0,0,1,0,0},
            {0,0,1,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0},
            {0,0,0,0,0} });
        
        
        
        BaseLayer = new int[width, height];
        Players = new int[width, height];
        DamageZones = new int[width, height];
        Invunerable = new bool[] { false, false };
        Swords = new int[width, height];
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (y > 0 && y < height - 1 && x > 0 && x < width - 1)
                    BaseLayer[x, y] = 0;
                else
                    BaseLayer[x, y] = 1;
            }
        }

        Players[width/2, 1] = 1;
        Players[width/2, height-2] = -1;
        Swords[width/2, 2] = 1;
        Swords[width/2, height-3] = -1;

    }
    
    //AI-generated deep copy method, i'm not writing all that lol
    public Map DeepCopy()
    {
        Map newMap = new Map(this.Width, this.Height, this.MaxViewDistance);
        
        // Copy arrays
        Array.Copy(this.BaseLayer, newMap.BaseLayer, this.Width * this.Height);
        Array.Copy(this.Players, newMap.Players, this.Width * this.Height);
        Array.Copy(this.Swords, newMap.Swords, this.Width * this.Height);
        Array.Copy(this.DamageZones, newMap.DamageZones, this.Width * this.Height);
        Array.Copy(this.Invunerable, newMap.Invunerable, this.Width * this.Height);

        // Copy lists
        newMap.P1NextActions = new List<int>(this.P1NextActions);
        newMap.P2NextActions = new List<int>(this.P2NextActions);
        foreach (var array in this.sideSwing)
        {
            var newArray = new int[array.GetLength(0), array.GetLength(1)];
            Array.Copy(array, newArray, array.Length);
            newMap.sideSwing.Add(newArray);
        }
        foreach (var array in this.forwardSwing)
        {
            var newArray = new int[array.GetLength(0), array.GetLength(1)];
            Array.Copy(array, newArray, array.Length);
            newMap.forwardSwing.Add(newArray);
        }
        foreach (var array in this.lunge)
        {
            var newArray = new int[array.GetLength(0), array.GetLength(1)];
            Array.Copy(array, newArray, array.Length);
            newMap.lunge.Add(newArray);
        }

        return newMap;
    }
    public int PlayGame(List<AI> players, bool displayGame)
    {
        if (displayGame)
        {
            Console.Clear();
            PrintFull();
        }

        int p1Input;
        if (players.Count < 2)
        {
            p1Input = GetPlayerInput(P1NextActions);
        }
        else
        {
            p1Input = GetAIInput(P1NextActions, VisionConeData(1), players[0]);
        }
        
        if (displayGame)
        {
            Console.Clear();
            PrintFull();
        }

        int p2Input;
        
        if (players.Count < 1)
        {
            p2Input = GetPlayerInput(P2NextActions);
        }
        else if (players.Count < 2)
        {
            p2Input = GetAIInput(P2NextActions, VisionConeData(-1), players[0]);
        }
        else
        {
            p2Input = GetAIInput(P2NextActions, VisionConeData(-1), players[1]);
        }
        int winner = Tick(p1Input, p2Input);
        
        if(displayGame)
            Console.WriteLine(winner);

        return winner;

    }

    public List<int> VisionConeData(int player) //Player is -1 or 1
    {
        Coordinate playerCoord = GetPlayerCoord(player);
        int direction = GetSwordDirection(player);
        List<int> final = new List<int>();
        int viewDistance = 0;
        if (direction == 0)
        {
            viewDistance = BaseLayer.GetLength(0) - playerCoord.Y;
        }
        else if (direction == 1)
        {
            viewDistance = BaseLayer.GetLength(1) - playerCoord.X;
            
        }
        else if (direction == 2)
        {
            viewDistance = BaseLayer.GetLength(0) - (BaseLayer.GetLength(0) - playerCoord.Y);
        }
        else if (direction == 3)
        {
            viewDistance = BaseLayer.GetLength(1) - (BaseLayer.GetLength(1) - playerCoord.X);
        }

        int i = 0;
        for (int y = 1; y < (viewDistance < MaxViewDistance? viewDistance: MaxViewDistance) ; y++)
        {
            for (int x = 0; x < 2 * (y) - 1; x++)
            {
                i++;
                Coordinate realArrayPos = new Coordinate(0, 0);
                if (direction == 0)
                {
                    realArrayPos = new Coordinate(playerCoord.X + x - y, playerCoord.Y + y);
                }
                else if (direction == 1)
                {
                    realArrayPos = new Coordinate(playerCoord.X + y, playerCoord.Y + x - y);
                }
                else if (direction == 2)
                {
                    realArrayPos = new Coordinate(playerCoord.X + x - y, playerCoord.Y - y);
                }
                else if (direction == 3)
                {
                    realArrayPos = new Coordinate(playerCoord.X - y, playerCoord.Y + x - y);
                }

                try
                {
                    final.Add(BaseLayer[realArrayPos.X, realArrayPos.Y]);
                    final.Add(Players[realArrayPos.X, realArrayPos.Y]);
                    final.Add(Swords[realArrayPos.X, realArrayPos.Y]);
                    final.Add(DamageZones[realArrayPos.X, realArrayPos.Y]);
                }
                catch(System.IndexOutOfRangeException)
                {
                    final.Add(1);
                    final.Add(0);
                    final.Add(0);
                    final.Add(0);
                }
                
           
            }
        }

        while (final.Count / 4 < MaxViewSquares)
        {
            final.Add(1);
            final.Add(0);
            final.Add(0);
            final.Add(0);
        }
        
        
        return final;
    
        

    }
    int GetPlayerInput(List<int> nextActions)
    {
        if (nextActions.Count > 0)
        {
            Console.WriteLine(nextActions.Count);
            int nextAction = nextActions[0];
            nextActions.RemoveAt(0);
            return nextAction;
        }
        char input = Console.ReadKey().KeyChar;
        switch (input)
        {
            case 'w':
                return 0;
            case 'd':
                return 1;
            case 's':
                return 2;
            case 'a':
                return 3;
            case 'i':
                return 4;
            case 'l':
                return 5;
            case 'k':
                return 6;
            case 'j':
                return 7;
            case ' ':
                return 8;

        }

        return 8;
    }
    int GetAIInput(List<int> nextActions, List<int> inputs, AI ai)
    {
        if (nextActions.Count > 0)
        {
            Console.WriteLine(nextActions.Count);
            int nextAction = nextActions[0];
            nextActions.RemoveAt(0);
            return nextAction;
        }
        //Legal Moves: 0,1,2,3,4,5,6,7,8
        List<double> aiAsk = ai.Ask(inputs);
        return aiAsk.IndexOf(aiAsk.Max());



    }
    public int Tick(int player1Input, int player2Input)
    {
        int winner = 0;
        DamageZones = new int[Width, Height];
        Coordinate p1ProposedPosition = new Coordinate(0, 0);
        Coordinate p2ProposedPosition = new Coordinate(0, 0);
        Coordinate p1ProposedSword = new Coordinate(0, 0);
        Coordinate p2ProposedSword = new Coordinate(0, 0);
        for (int player = 1; player >= -1; player-=2)
        {
            Coordinate proposedPosition = GetPlayerCoord(player);
            Coordinate proposedSwordPosition = GetSwordCoord(player);
            Coordinate swordPosition = GetSwordCoord(player);
            Coordinate swordDirection = GetSwordVector(player);
            switch ( player == 1? player1Input : player2Input)
            {
                    
                case 0: //forwards
                    proposedPosition = GetSwordCoord(player);
                    proposedSwordPosition = proposedPosition + swordDirection;
                    break;
                case 1: //Turn Right
                    proposedSwordPosition = new Coordinate(swordDirection.Y + proposedPosition.X,
                        proposedPosition.Y + -swordDirection.X);
                    break;
                case 2: //backwards
                    proposedPosition = proposedPosition - swordDirection;
                    proposedSwordPosition = proposedPosition + swordDirection;
                    break;
                case 3: //Turn Left
                    proposedSwordPosition = new Coordinate(-swordDirection.Y + proposedPosition.X,
                        proposedPosition.Y + swordDirection.X);
                    break;
                case 4: //Swing Forward
                    if (player == 1)
                    {
                        P1NextActions.Add(11);
                        P1NextActions.Add(10);
                    }
                    else
                    {
                        P2NextActions.Add(11);
                        P2NextActions.Add(10);
                    }
                    break;
                case 11: //Forward Swing 2 (hidden
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, forwardSwing[GetSwordDirection(player)]);
                    break;
                case 5: //Swing Right
                    int direction = GetSwordDirection(player);
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, sideSwing[direction + direction >= 2? -2:2 ]);
                    if (player == 1)
                    {
                        P1NextActions.Add(10);
                    }
                    else
                    {
                        P2NextActions.Add(10);
                    }
                    break;
                case 6: //Lunge
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, lunge[GetSwordDirection(player)]);
                    if (player == 1)
                    {
                        P1NextActions.Add(9);
                    }
                    else
                    {
                        P2NextActions.Add(9);
                    }
                    break;
                case 7: //Swing Left
                    if (player == 1)
                    {
                        P1NextActions.Add(10);
                    }
                    else
                    {
                        P2NextActions.Add(10);
                    }
                    DamageZones = GenerateDamageZone(proposedPosition, DamageZones, sideSwing[GetSwordDirection(player)]);
                    break;
                case 8: //Dodge
                    if (player == 1)
                    {
                        P1NextActions.Add(10);
                        Invunerable[0] = true;
                    }
                    else
                    {
                        P2NextActions.Add(10);
                        Invunerable[1] = true;
                    }
                    break;
                case 9: //Lunge pt 2 (Hidden) 
                    proposedPosition = new Coordinate(swordPosition.X + swordDirection.X, swordPosition.Y + swordDirection.Y);
                    proposedSwordPosition = new Coordinate(swordPosition.X + swordDirection.X * 2,
                        swordPosition.Y + swordDirection.Y * 2);
                    break;
                case 10: // Wait (Hidden)
                    break;



                

            }
            if (player == 1)
            {
                p1ProposedPosition = proposedPosition;
                p1ProposedSword = proposedSwordPosition;
            }
            else
            {
                p2ProposedPosition = proposedPosition;
                p2ProposedSword = proposedSwordPosition;
            }
            
            
            
            
            
        }
        
        //If a player's proposed position is in a damage zone, they lose. If both players are in damage zones, they cancel out.
        //If a player's proposed position is in a wall or other player's proposed position, they don't move
        if (DamageZones[p1ProposedPosition.X, p1ProposedPosition.Y] >
            DamageZones[p2ProposedPosition.X, p2ProposedPosition.Y])
        {
            winner = 2;
        }
        else if (DamageZones[p1ProposedPosition.X, p1ProposedPosition.Y] <
                 DamageZones[p2ProposedPosition.X, p2ProposedPosition.Y])
        {
            winner = 1;
        }
        else if (p1ProposedSword.Equals(p2ProposedPosition) && !p2ProposedSword.Equals((p1ProposedPosition)))
        {
            winner = 1;
        }
        else if (p2ProposedSword.Equals((p1ProposedPosition)))
        {
            winner = 2;
        }
        else if (!p1ProposedPosition.Equals(p2ProposedPosition) && !p1ProposedSword.Equals(p2ProposedSword))
        {
            if (BaseLayer[p1ProposedPosition.X, p1ProposedPosition.Y] == 0 && BaseLayer[p1ProposedSword.X, p1ProposedSword.Y] == 0)
            {
                Coordinate p1 = GetPlayerCoord(1);
                Coordinate swordPosition = GetSwordCoord(1);
                Coordinate p2 = GetPlayerCoord(-1);
                Coordinate p2SwordPosition = GetSwordCoord(-1);
                Players[p1.X, p1.Y] = 0;
                Players[p1ProposedPosition.X, p1ProposedPosition.Y] = 1;
                Swords[swordPosition.X, swordPosition.Y] = 0;
                Swords[p1ProposedSword.X, p1ProposedSword.Y] = 1;
                
                if (BaseLayer[p2ProposedPosition.X, p2ProposedPosition.Y] == 0&& BaseLayer[p2ProposedSword.X, p2ProposedSword.Y] == 0)
                {
                    
                    Players[p2.X, p2.Y] = p2.Equals(p1ProposedPosition) ? 1:0;//Edge case if player follows directly behind other player somehow
                    Players[p2ProposedPosition.X, p2ProposedPosition.Y] = -1;
                    Swords[p2SwordPosition.X, p2SwordPosition.Y] = p2SwordPosition.Equals(p1ProposedSword) ? 1:0;//Same edge case but sword goes into position the other sword just left
                    Swords[p2ProposedSword.X, p2ProposedSword.Y] = -1;
                
                }
                
                
            }

            else if (BaseLayer[p2ProposedPosition.X, p2ProposedPosition.Y] == 0&& BaseLayer[p2ProposedSword.X, p2ProposedSword.Y] == 0)
            {
                Coordinate p2 = GetPlayerCoord(-1);
                Coordinate swordPosition = GetSwordCoord(-1);
                Players[p2.X, p2.Y] = 0;
                Players[p2ProposedPosition.X, p2ProposedPosition.Y] = -1;
                Swords[swordPosition.X, swordPosition.Y] = 0;
                Swords[p2ProposedSword.X, p2ProposedSword.Y] = -1;
                
            }
        }
        else if (p1ProposedSword.Equals(p2ProposedPosition))
        {
            winner = 1;
        }
        else if (p2ProposedSword.Equals((p1ProposedPosition)))
        {
            winner = 2;
        }
        else if (GetPlayerCoord(1).Equals(p1ProposedSword))//edge case: sword hits sword while backing away doesn't stop player backing away
        {
            Coordinate p1 = GetPlayerCoord(1);
            Coordinate swordPosition = GetSwordCoord(1);
            Players[p1.X, p1.Y] = 0;
            Players[p1ProposedPosition.X, p1ProposedPosition.Y] = 1;
            Swords[swordPosition.X, swordPosition.Y] = 0;
            Swords[p1ProposedSword.X, p1ProposedSword.Y] = 1;
        }
        else if (GetPlayerCoord(-1).Equals(p2ProposedSword))
        {
            Coordinate p2 = GetPlayerCoord(-1);
            Coordinate swordPosition = GetSwordCoord(-1);
            Players[p2.X, p2.Y] = 0;
            Players[p2ProposedPosition.X, p2ProposedPosition.Y] = -1;
            Swords[swordPosition.X, swordPosition.Y] = 0;
            Swords[p2ProposedSword.X, p2ProposedSword.Y] = -1;
        }

        return winner;
    }
    public void PrintFull()
    {
        Console.WriteLine();
        for (int y = Height - 1; y >= 0 ; y--)
        {
            for (int x = 0; x < Width ; x++)
            {
                Console.BackgroundColor = ConsoleColor.Black;
                Console.ForegroundColor = ConsoleColor.Black;
                if (DamageZones[x, y] == 1)
                {
                    Console.BackgroundColor = ConsoleColor.Red;
                }
                else if (BaseLayer[x, y] == 0)
                {
                    Console.BackgroundColor = ConsoleColor.DarkYellow;
                }
                if (Players[x, y] != 0)
                {
                    if (Players[x, y] == 1 && Invunerable[0])
                        Console.BackgroundColor = ConsoleColor.Blue;
                    Console.Write(Players[x,y] == 1? "A":"B");
                }
                else if (Swords[x, y] != 0)
                {
                    Console.Write("S");
                }
                else
                {
                    Console.Write($" ");
                }
                
            }
            Console.WriteLine();
        }
        Console.BackgroundColor = ConsoleColor.Black;
        Console.ForegroundColor = ConsoleColor.Gray;
    }
    private Coordinate GetPlayerCoord(int player)
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (Players[x, y] == player)
                    return new Coordinate(x, y);
            }
        }

        throw new Exception("Player not found");
    }
    private Coordinate GetSwordCoord(int player)
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (Swords[x, y] == player)
                    return new Coordinate(x, y);
            }
        }

        throw new Exception("Sword not found");
    }
    private Coordinate GetSwordVector(int player) // acts like a vector from the player, add this to player's pos to get sword pos
    {
        return GetSwordCoord(player) - GetPlayerCoord(player);
    }
    private int GetSwordDirection(int player) // 0 = north, 1, east, 2= south, 3 = west
    {
        Coordinate swordVector = GetSwordVector(player);
        if (swordVector.Equals(new Coordinate(0, 1)))
            return 0;
        if (swordVector.Equals(new Coordinate(1, 0)))
            return 1;
        if (swordVector.Equals(new Coordinate(0, -1)))
            return 2;
        if (swordVector.Equals(new Coordinate(-1, 0)))
            return 3;
        else
        {
            throw new Exception("sword direction broken");
        }
    

    }
    private int[,] GenerateDamageZone(Coordinate centerPos, int[,] damageZones, int[,] swingData)
    {
        int rows = damageZones.GetLength(0);
        int cols = damageZones.GetLength(1);
        int[,] final = new int[rows, cols];
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                final[i, j] = damageZones[i, j];
            }
        }
        
        if (swingData.GetLength(0) % 2 == 0 || swingData.GetLength(1) % 2 == 0)
        {
            throw new Exception("even-sided swing data");
        }



        for (int x = 0; x < swingData.GetLength(0); x++)
        {
            for (int y = 0; y < swingData.GetLength(1); y++)
            {
                Coordinate realArrayPos = new Coordinate(centerPos.X + (-swingData.GetLength(0)) / 2 + x, centerPos.Y + (-swingData.GetLength(1)) / 2 + y);
                if (realArrayPos.X >= 0 && realArrayPos.X < Width && realArrayPos.Y >= 0 && realArrayPos.Y < Height)
                {

                    if (swingData[x, y] == 1)
                    {
                        final[realArrayPos.X, realArrayPos.Y] = 1;
                    }
                      
                }
                

            }
        }

        return final;
    }
    
}

class Coordinate
{
    public int X { get;}
    public int Y { get;}
    public Coordinate(int x, int y)
    {
        X = x;
        Y = y;
    }

    public static Coordinate operator +(Coordinate a, Coordinate b)
    {
        return new Coordinate(a.X + b.X, a.Y + b.Y);
    }
    public static Coordinate operator -(Coordinate a, Coordinate b)
    {
        return new Coordinate(a.X - b.X, a.Y - b.Y);
    }

    public override string ToString()
    {
        return $"({X}, {Y})";
    }
    
    public bool Equals(Coordinate other)
    {
        return X == other.X && Y == other.Y;
    }

    public double Magnitude()
    {
        return Math.Sqrt(X * X + Y * Y);
    }
    
    
}